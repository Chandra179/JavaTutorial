============================
adapter: converts the interface of one object so that another object can understand it.
============================

- roundHole (class)
- roundPeg (class)
- squarePeg (class)

// convert square to round
- squarePegAdapter extends roundPeg
  -> public squarePegAdapter(squarePeg p)
  -> @override getRadius()

- client:
  -> squarePeg p = new squarePeg(20)
  -> squarePegAdapter tes = new squarePegAdapter(p)


======================================================================
bridge: split a large class or a set of closely related 
classes into two separate hierarchies
======================================================================

Device (interface)
Radio implements Device
Tv implements Device

Remote(interface)
BasicRemote implements Remote
AdvancedRemote extend BasicRemote

client:
-> Device samsung = new Tv();
-> BasicRemote basicRemote = new BasicRemote(samsung);
-> basicRemote.switchChannel();


===============================================================
composite: compose objects into tree structures and then work 
with these structures as if they were individual objects.
===============================================================

Department (interface) -> public printDepartmentName();
FinancialDepartment implements Department -> override printDepartmentName();
SalesDepartment implements Department -> override printDepartmentName();

HeadDepartment implements Department ->
- childDepartments.forEach(Department::printDepartmentName);

Department salesDepartment = new SalesDepartment(1, "Sales department");
Department financialDepartment = new FinancialDepartment(2, "Financial department");
HeadDepartment headDepartment = new HeadDepartment(3, "Head department");

headDepartment.addDepartment(salesDepartment);
headDepartment.addDepartment(financialDepartment);

headDepartment.getName();
headDepartment.printDepartmentName();



=====================================================================
Decorator: design pattern that lets you attach new behaviors to objects by
placing these objects inside special wrapper objects that contain the behaviors.
=====================================================================

ChristmasTree (interface) -> String decorate();
ChristmasTreeImpl implements ChristmasTree ->
- override decorate() : return "Christmas tree";
abstract TreeDecorator implements ChristmasTree -> override decorate();

BubbleLights extends TreeDecorator ->
- decorate() : return super.decorate + " with Bubble lights";
Tinsel extends TreeDecorator ->
- decorate() : return super.decorate + " with Tinsel";



========================================
FACADE: design pattern that provides a simplified interface to a library, a framework,
or any other complex set of classes.
========================================
public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println("VideoConversionFacade: conversion started.");
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println("VideoConversionFacade: conversion completed.");
        return result;
    }
}

public static void main(String[] args) {
        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo("youtubevideo.ogg", "mp4");
        // ...
    }


==================================================================================
FLYWEIGHT:  structural design pattern that lets you fit more objects into the
available amount of RAM by sharing common parts of state between
multiple objects instead of keeping all of the data in each object.
==================================================================================


=======================================
PROXY: design pattern that lets you provide a substitute or placeholder for another 
object. A proxy controls access to the original object, allowing you to perform 
something either before or after the request gets through to the original object.
=======================================

caching class/method, so if user request multiple times, the cache method/class
will be calles instead of the original method.
